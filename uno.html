<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO - No Mercy (Multijugador)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            overflow: hidden;
        }
        
        /* Estilos de Cartas */
        .card {
            width: 80px;
            height: 112px;
            border-radius: 8px;
            display: inline-block;
            position: relative;
            margin: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .card img {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            object-fit: cover;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        .card:hover { transform: translateY(-10px) scale(1.05); z-index: 50; }
        
        /* Estilo para el color elegido en comodines */
        .card .color-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 6px;
            box-shadow: 0 0 15px 5px var(--chosen-color, transparent);
            border: 3px solid var(--chosen-color, transparent);
            pointer-events: none;
        }

        /* √Åreas de Juego */
        #my-hand-area {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            min-height: 120px;
            padding: 10px;
            overflow-x: auto;
            overflow-y: hidden;
        }
        #opponents-area {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 10px;
            min-height: 100px;
        }
        .opponent {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 10px;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
        }
        .opponent.active-player {
            background-color: rgba(234, 179, 8, 0.3);
            box-shadow: 0 0 15px rgba(234, 179, 8, 0.5);
        }
        .opponent .card {
            width: 50px;
            height: 70px;
            font-size: 16px;
        }
        
        /* Estilo para jugador perdido */
        .opponent.lost-player {
            opacity: 0.5;
            filter: grayscale(80%);
        }
        .opponent .lost-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-10deg);
            background-color: #ef4444;
            color: white;
            padding: 4px 12px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 1.1rem;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }
        
        .btn { transition: all 0.2s ease-in-out; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: translateY(0); box-shadow: none; }
        
        #modal-overlay { background-color: rgba(0, 0, 0, 0.7); }
        .hidden { display: none; }
        
        /* Chat */
        #chat-container {
            height: calc(100vh - 100px);
            max-height: 600px;
            transition: all 0.3s ease-in-out;
            position: fixed;
            right: 0;
            top: 80px;
            width: 350px;
            z-index: 100;
            transform: translateX(100%);
        }
        #chat-container.visible {
            transform: translateX(0);
        }
        #chat-messages::-webkit-scrollbar { width: 8px; }
        #chat-messages::-webkit-scrollbar-track { background: #1f2937; }
        #chat-messages::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px;}
        #chat-toggle-btn { position: fixed; top: 20px; right: 20px; z-index: 101; }
        #chat-notification { position: absolute; top: 0; right: 0; width: 12px; height: 12px; background-color: #ef4444; border-radius: 50%; border: 2px solid #1a202c; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(0.9); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } 100% { transform: scale(0.9); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }

    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <!-- Bot√≥n de Chat -->
    <button id="chat-toggle-btn" class="btn bg-gray-700 hover:bg-gray-600 p-3 rounded-full shadow-lg hidden">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
        </svg>
        <span id="chat-notification" class="hidden"></span>
    </button>

    <!-- Modal para unirse/crear sala -->
    <div id="modal-overlay" class="fixed inset-0 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center w-full max-w-sm">
            <h2 class="text-3xl font-bold mb-4 text-yellow-300">UNO: NO MERCY</h2>
            <p id="modal-error" class="text-red-400 mb-3 min-h-[20px]"></p>
            <div id="entry-options">
                 <input type="text" id="nickname-input" class="w-full bg-gray-700 text-white p-3 rounded-md mb-4" placeholder="Ingresa tu apodo...">
                 <button id="create-room-btn" class="btn bg-green-500 hover:bg-green-600 w-full text-white font-bold py-3 px-6 rounded-lg text-lg mb-3">Crear Sala</button>
                 <button id="show-join-btn" class="btn bg-blue-500 hover:bg-blue-600 w-full text-white font-bold py-3 px-6 rounded-lg text-lg">Unirse a Sala</button>
            </div>
            <div id="join-options" class="hidden">
                 <input type="text" id="room-id-input" class="w-full bg-gray-700 text-white p-3 rounded-md mb-4" placeholder="Ingresa ID de la sala (6 d√≠gitos)..." maxlength="6">
                 <button id="join-room-btn" class="btn bg-blue-500 hover:bg-blue-600 w-full text-white font-bold py-3 px-6 rounded-lg text-lg mb-3">Unirse</button>
                 <button id="back-to-entry-btn" class="text-gray-400 hover:text-white">Volver</button>
            </div>
        </div>
    </div>

    <!-- Contenedor del Juego -->
    <div id="game-container" class="w-full h-screen flex flex-col items-center justify-between p-4 hidden">
        
        <!-- √Årea de Oponentes (Arriba) -->
        <div id="opponents-area" class="w-full"></div>

        <!-- √Årea de Mensajes e Info (Centro) -->
        <div class="flex flex-col items-center justify-center text-center">
            <p id="message-el" class="text-2xl text-yellow-300 font-semibold mb-2 min-h-[32px]"></p>
            <p class="text-sm text-gray-400">ID de Sala: <strong id="room-id-el" class="text-yellow-300 font-mono"></strong></p>
            <p class="text-sm text-gray-400">Tu ID: <span id="user-id-el" class="font-mono"></span></p>
        </div>

        <!-- √Årea de la Mesa (Centro) -->
        <div id="table-area" class="flex justify-center items-center space-x-8 my-4">
            <!-- Mazo de Robar -->
            <div id="deck-pile" class="cursor-pointer card">
                <img src="cards/back cover.PNG" alt="Mazo" class="w-full h-full rounded-md object-cover">
            </div>
            <!-- Pila de Descarte -->
            <div id="discard-pile" class="relative"></div>
            <div id="draw-stack-indicator" class="text-2xl font-bold text-red-500 p-4 bg-gray-900/50 rounded-lg hidden">
                ¬°ROBA <span id="draw-stack-count">0</span>!
            </div>
        </div>
        
        <!-- Botones de Acci√≥n -->
        <div id="action-buttons" class="flex justify-center space-x-4 mb-4">
            <button id="start-game-btn" class="btn bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg hidden">INICIAR JUEGO</button>
            <button id="say-uno-btn" class="btn bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg hidden">¬°UNO!</button>
        </div>

        <!-- Contador de Cartas Propias -->
        <div id="my-card-count-container" class="text-center mb-2">
            <span class="text-xl font-bold text-white">Tus Cartas: 
                <span id="my-card-count-el" class="text-yellow-300">0</span>
            </span>
        </div>

        <!-- Mi Mano (Abajo) -->
        <div id="my-hand-area" class="w-full bg-gray-900/50 p-2 rounded-lg"></div>
    </div>
    
    <!-- Modal de Selecci√≥n de Color -->
    <div id="color-picker-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center">
            <h3 class="text-2xl font-bold mb-6 text-white">Elige un color</h3>
            <div class="flex space-x-4">
                <button class="color-choice-btn w-20 h-20 rounded-full border-4 border-transparent hover:border-white transition" style="background-color: #ef4444;" data-color="red"></button>
                <button class="color-choice-btn w-20 h-20 rounded-full border-4 border-transparent hover:border-white transition" style="background-color: #22c55e;" data-color="green"></button>
                <button class="color-choice-btn w-20 h-20 rounded-full border-4 border-transparent hover:border-white transition" style="background-color: #3b82f6;" data-color="blue"></button>
                <button class="color-choice-btn w-20 h-20 rounded-full border-4 border-transparent hover:border-white transition" style="background-color: #eab308;" data-color="yellow"></button>
            </div>
        </div>
    </div>

    <!-- Modal de Intercambio de Mano (Carta 7) -->
    <div id="swap-hand-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center w-full max-w-md">
            <h3 class="text-2xl font-bold mb-6 text-white">¬°Carta 7! Elige con qui√©n intercambiar mano:</h3>
            <div id="swap-player-list" class="flex flex-col space-y-3"></div>
        </div>
    </div>

    <!-- Contenedor del Chat -->
    <div id="chat-container" class="bg-gray-800/80 backdrop-blur-sm rounded-lg p-4 flex flex-col">
        <h3 class="text-2xl font-bold mb-4 text-center">Chat de la Sala</h3>
        <div id="chat-messages" class="flex-grow overflow-y-auto mb-4 pr-2"></div>
        <div id="emoji-picker" class="mb-2">
            <button class="emoji-btn text-2xl p-1">üòÇ</button>
            <button class="emoji-btn text-2xl p-1">üëç</button>
            <button class="emoji-btn text-2xl p-1">üî•</button>
            <button class="emoji-btn text-2xl p-1">üò¢</button>
            <button class="emoji-btn text-2xl p-1">üòé</button>
        </div>
        <div class="flex">
            <input type="text" id="chat-input" class="w-full bg-gray-700 text-white p-3 rounded-l-md" placeholder="Escribe un mensaje...">
            <button id="send-chat-btn" class="btn bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-r-md">Enviar</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, getDoc, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // CONFIGURACI√ìN DE FIREBASE (Usa la tuya)
        const firebaseConfig = {
            apiKey: "AIzaSyA6uydlodXo1vnyqoocwzHytwt5W0riIDQ",
            authDomain: "blackjack-d6b7b.firebaseapp.com",
            projectId: "blackjack-d6b7b",
            storageBucket: "blackjack-d6b7b.appspot.com",
            messagingSenderId: "705363226577",
            appId: "1:705363226577:web:214cf8baa2c9fb48e73af0"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;
        let currentGameData = null;
        let gameRef = null;
        let unsubscribe = null;
        let isChatVisible = false;
        let lastMessageCount = 0;
        let pendingWildCard = null;
        const playerColors = ['#60a5fa', '#34d399', '#f87171', '#fbbf24', '#a78bfa', '#f472b6', '#76e6d1'];
        const CARD_IMAGE_PATH = "cards/";

        // Elementos UI
        const modalOverlay = document.getElementById("modal-overlay");
        const nicknameInput = document.getElementById("nickname-input");
        const modalErrorEl = document.getElementById("modal-error");
        const entryOptions = document.getElementById("entry-options");
        const joinOptions = document.getElementById("join-options");
        const createRoomBtn = document.getElementById("create-room-btn");
        const showJoinBtn = document.getElementById("show-join-btn");
        const joinRoomBtn = document.getElementById("join-room-btn");
        const roomIdInput = document.getElementById("room-id-input");
        const backToEntryBtn = document.getElementById("back-to-entry-btn");
        const gameContainer = document.getElementById("game-container");
        const messageEl = document.getElementById("message-el");
        const roomIdEl = document.getElementById("room-id-el");
        const userIdEl = document.getElementById("user-id-el");
        const opponentsArea = document.getElementById("opponents-area");
        const deckPile = document.getElementById("deck-pile");
        const discardPile = document.getElementById("discard-pile");
        const drawStackIndicator = document.getElementById("draw-stack-indicator");
        const drawStackCount = document.getElementById("draw-stack-count");
        const myHandArea = document.getElementById("my-hand-area");
        const myCardCountEl = document.getElementById("my-card-count-el");
        const startGameBtn = document.getElementById("start-game-btn");
        const sayUnoBtn = document.getElementById("say-uno-btn");
        const colorPickerModal = document.getElementById("color-picker-modal");
        const swapHandModal = document.getElementById("swap-hand-modal");
        const swapPlayerList = document.getElementById("swap-player-list");
        const chatContainer = document.getElementById("chat-container");
        const chatMessages = document.getElementById("chat-messages");
        const chatInput = document.getElementById("chat-input");
        const sendChatBtn = document.getElementById("send-chat-btn");
        const emojiPicker = document.getElementById("emoji-picker");
        const chatToggleBtn = document.getElementById("chat-toggle-btn");
        const chatNotification = document.getElementById("chat-notification");

        onAuthStateChanged(auth, user => { if (user) currentUser = user; });
        signInAnonymously(auth);

        // LOBBY
        function validateNickname() {
            const nickname = nicknameInput.value.trim();
            if (nickname.length < 3) { modalErrorEl.textContent = "Apodo min 3 letras."; return null; }
            return nickname;
        }

        showJoinBtn.addEventListener('click', () => { entryOptions.classList.add('hidden'); joinOptions.classList.remove('hidden'); modalErrorEl.textContent = ''; });
        backToEntryBtn.addEventListener('click', () => { joinOptions.classList.add('hidden'); entryOptions.classList.remove('hidden'); modalErrorEl.textContent = ''; });

        createRoomBtn.addEventListener('click', async () => {
            const nickname = validateNickname(); if (!nickname) return;
            const roomId = Math.floor(100000 + Math.random() * 900000).toString();
            gameRef = doc(db, 'uno-no-mercy-games', roomId);
            const newPlayer = { uid: currentUser.uid, name: nickname, hand: [], cardCount: 0, color: playerColors[0], isSafe: false, status: 'playing' };
            const newGameData = {
                roomId, players: [newPlayer], status: 'waiting', creatorUid: currentUser.uid, message: "Esperando...", chatMessages: [], deck: [], discardPile: [],
                currentPlayerIndex: 0, drawStack: 0, stackType: null, playDirection: 1, lastColorCalled: null, mustPlayColor: null, gamePhase: 'lobby'
            };
            await setDoc(gameRef, newGameData);
            subscribeToGame(gameRef);
        });

        joinRoomBtn.addEventListener('click', async () => {
            const nickname = validateNickname(); if (!nickname) return;
            const roomId = roomIdInput.value.trim();
            if (roomId.length !== 6) { modalErrorEl.textContent = "ID debe ser 6 d√≠gitos."; return; }
            gameRef = doc(db, 'uno-no-mercy-games', roomId);
            const gameDoc = await getDoc(gameRef);
            if (!gameDoc.exists()) { modalErrorEl.textContent = "Sala no encontrada."; return; }
            const data = gameDoc.data();
            if (data.status !== 'waiting') { modalErrorEl.textContent = "Ya comenz√≥."; return; }
            if (data.players.length >= 7) { modalErrorEl.textContent = "Sala llena."; return; }
            if (!data.players.some(p => p.uid === currentUser.uid)) {
                const newPlayer = { uid: currentUser.uid, name: nickname, hand: [], cardCount: 0, color: playerColors[data.players.length % playerColors.length], isSafe: false, status: 'playing' };
                await updateDoc(gameRef, { players: arrayUnion(newPlayer) });
            }
            subscribeToGame(gameRef);
        });

        // CHAT
        async function sendMessage() {
            const text = chatInput.value.trim();
            if (text === "" || !currentGameData) return;
            const me = currentGameData.players.find(p => p.uid === currentUser.uid);
            if (!me) return;
            await updateDoc(gameRef, { chatMessages: arrayUnion({ senderName: me.name, senderUid: currentUser.uid, text, timestamp: new Date() }) });
            chatInput.value = "";
        }
        chatToggleBtn.addEventListener("click", () => { isChatVisible = !isChatVisible; chatContainer.classList.toggle("visible", isChatVisible); if(isChatVisible) chatNotification.classList.add("hidden"); });
        sendChatBtn.addEventListener("click", sendMessage);
        chatInput.addEventListener("keydown", (e) => { if (e.key === "Enter") sendMessage(); });
        emojiPicker.addEventListener("click", (e) => { if (e.target.classList.contains("emoji-btn")) { chatInput.value += e.target.textContent; chatInput.focus(); } });

        // CORE GAME FUNCTIONS
        function subscribeToGame(ref) {
            if (unsubscribe) unsubscribe();
            unsubscribe = onSnapshot(ref, (docSnap) => {
                if (docSnap.exists()) { currentGameData = docSnap.data(); renderGame(currentGameData); }
                else { messageEl.textContent = "Sala cerrada."; setTimeout(() => window.location.reload(), 3000); }
            });
            modalOverlay.classList.add("hidden");
            gameContainer.classList.remove("hidden");
            chatToggleBtn.classList.remove("hidden");
        }

        function renderGame(data) {
            if (!data) return;
            messageEl.textContent = data.message || "";
            roomIdEl.textContent = data.roomId;
            userIdEl.textContent = currentUser.uid;

            // Render Oponentes
            opponentsArea.innerHTML = "";
            const me = data.players.find(p => p.uid === currentUser.uid);
            data.players.forEach((player, index) => {
                if (player.uid === currentUser.uid) return;
                const div = document.createElement('div');
                div.className = 'opponent';
                if (player.status === 'lost') { div.classList.add('lost-player'); div.innerHTML += '<span class="lost-status">PERDI√ì</span>'; }
                else if (index === data.currentPlayerIndex) div.classList.add('active-player');
                div.innerHTML += `<p class="font-bold text-sm" style="color: ${player.color};">${player.name}</p>
                    <div class="card"><img src="${CARD_IMAGE_PATH}back cover.PNG" alt="Dorso"></div>
                    <span class="text-lg font-bold">${player.cardCount}</span>
                    ${player.isSafe ? '<span class="text-yellow-400 text-xs">UNO!</span>' : ''}`;
                opponentsArea.appendChild(div);
            });

            // Descarte
            discardPile.innerHTML = "";
            if (data.discardPile.length > 0) {
                const top = data.discardPile[data.discardPile.length - 1];
                const cardEl = createCardElement(top, false);
                // Mostrar overlay si es comod√≠n o si es Sad Face
                if ((top.color === 'black' || top.type === 'wild-color-roulette') && data.lastColorCalled) {
                    cardEl.innerHTML += `<div class="color-overlay" style="--chosen-color: ${data.lastColorCalled};"></div>`;
                }
                discardPile.appendChild(cardEl);
            } else discardPile.innerHTML = `<div class="w-20 h-28 border-2 border-dashed border-gray-600 rounded-lg"></div>`;

            drawStackIndicator.classList.toggle('hidden', data.drawStack <= 0);
            drawStackCount.textContent = data.drawStack;

            // Mi Mano
            myHandArea.innerHTML = "";
            if (me) {
                if (me.status === 'lost') {
                    myHandArea.innerHTML = '<p class="text-red-500 text-2xl font-bold">HAS PERDIDO</p>';
                    myCardCountEl.textContent = me.cardCount;
                } else {
                    me.hand.forEach(card => {
                        const el = createCardElement(card, true);
                        el.addEventListener('click', () => onCardClick(card));
                        myHandArea.appendChild(el);
                    });
                    myCardCountEl.textContent = me.cardCount;
                }
            }

            // Controles
            const amICurrent = data.players[data.currentPlayerIndex]?.uid === currentUser.uid;
            startGameBtn.classList.add('hidden');
            sayUnoBtn.classList.add('hidden');

            if (data.status === 'waiting') {
                startGameBtn.classList.remove('hidden');
                startGameBtn.textContent = "INICIAR JUEGO";
                startGameBtn.disabled = data.creatorUid !== currentUser.uid || data.players.length < 2;
                if (data.players.length < 2) messageEl.textContent = "Esperando jugadores...";
            } else if (data.status === 'playing' && me?.status === 'playing') {
                if (me?.cardCount === 1 && !me.isSafe) sayUnoBtn.classList.remove('hidden');
                
                // Mensajes de estado especiales
                if (data.gamePhase === 'swap-hand-choice' && amICurrent) {
                    messageEl.textContent = "Elige un jugador para intercambiar tu mano.";
                    swapPlayerList.innerHTML = '';
                    data.players.forEach(p => {
                        if (p.uid === currentUser.uid || p.status === 'lost') return;
                        const btn = document.createElement('button');
                        btn.textContent = `${p.name} (${p.cardCount})`;
                        btn.className = 'btn w-full p-3 rounded-lg font-semibold text-white transition';
                        btn.style.backgroundColor = p.color;
                        btn.addEventListener('click', () => performHandSwap(p.uid));
                        swapPlayerList.appendChild(btn);
                    });
                    swapHandModal.classList.remove('hidden');
                } else if (data.gamePhase === 'repeat-play' && amICurrent) {
                    messageEl.textContent = `¬°REPITE! Juega otra carta ${data.mustPlayColor} o roba.`;
                }
            } else if (data.status === 'finished') {
                messageEl.textContent = data.message;
                if (data.creatorUid === currentUser.uid) {
                    startGameBtn.classList.remove('hidden');
                    startGameBtn.textContent = "JUGAR DE NUEVO";
                    startGameBtn.disabled = false;
                }
            }
            
            if (data.gamePhase !== 'swap-hand-choice') swapHandModal.classList.add('hidden');

            // Chat render
            const msgs = data.chatMessages || [];
            if (msgs.length > lastMessageCount && !isChatVisible && msgs[msgs.length - 1].senderUid !== currentUser.uid) chatNotification.classList.remove("hidden");
            lastMessageCount = msgs.length;
            chatMessages.innerHTML = '';
            msgs.forEach(m => {
                const s = data.players.find(p => p.uid === m.senderUid);
                chatMessages.innerHTML += `<div class="mb-2 p-2 rounded-md bg-gray-700 break-words"><strong style="color:${s?s.color:'#ccc'}">${m.senderName}:</strong> ${m.text}</div>`;
            });
            if (chatMessages.scrollHeight > chatMessages.clientHeight) chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function createCardElement(card, isMyCard) {
            const div = document.createElement('div');
            div.className = 'card' + (isMyCard ? ' my-card' : '');
            div.innerHTML = `<img src="${CARD_IMAGE_PATH}${card.image}" alt="${card.type}">`;
            return div;
        }

        // MAZO (MODIFICADO: M√ÅS CARTAS DE ATAQUE)
        function createSingleDeck() {
            let deck = [];
            const colors = ['red', 'green', 'blue', 'yellow'];
            const colorMap = { red: 'rojo', green: 'verde', blue: 'azul', yellow: 'amarillo' };
            let id = 0;

            for (const color of colors) {
                const cName = colorMap[color];
                // N√∫meros 0-9
                deck.push({ id: id++, type: 'number', color, value: '0', image: `0 ${cName}.png` });
                for (let i = 1; i <= 9; i++) {
                    const cd = { type: 'number', color, value: i.toString(), image: `${i} ${cName}.png` };
                    deck.push({ ...cd, id: id++ }); deck.push({ ...cd, id: id++ });
                }
                // Acci√≥n B√°sica
                const skip = { type: 'skip', color, value: 'S', image: `bloqueo ${cName}.png` };
                deck.push({ ...skip, id: id++ }); deck.push({ ...skip, id: id++ });
                
                const rev = { type: 'reverse', color, value: 'R', image: `reversa ${cName}.png` };
                deck.push({ ...rev, id: id++ }); deck.push({ ...rev, id: id++ });

                // Repite
                const rep = { type: 'repeat', color, value: 'REP', image: `repite ${cName}.png` };
                deck.push({ ...rep, id: id++ }); deck.push({ ...rep, id: id++ });

                // Bajar Color
                const baj = { type: 'discard-all', color, value: 'BAJ', image: `bajar color ${cName}.png` };
                let imgName = `bajar color ${cName}.png`;
                if(color === 'red') imgName = "baja color rojo.png";
                
                deck.push({ ...baj, image: imgName, id: id++ }); 
                deck.push({ ...baj, image: imgName, id: id++ });

                // Draw 2 (AUMENTADO: 4 copias por color)
                let d2Img = `mas 2 ${cName}.png`;
                if(color==='yellow') d2Img = "mas2 amarillo.png";
                if(color==='blue') d2Img = "mas2 azul.png";
                if(color==='red') d2Img = "mas 2 rojo.png";
                if(color==='green') d2Img = "mas 2 verde.png";
                
                // Antes: 2 copias. Ahora: 4 copias.
                for(let k=0; k<4; k++) deck.push({ id: id++, type: 'draw2', color, value: '+2', image: d2Img });

                // Draw 4 (AUMENTADO: 4 copias por color)
                // Antes: 2 copias. Ahora: 4 copias.
                for(let k=0; k<4; k++) deck.push({ id: id++, type: 'draw4', color, value: '+4', image: `mas4 ${cName}.png` });
            }

            // Cartas Negras (AUMENTADAS SIGNIFICATIVAMENTE)
            const d6 = { type: 'wild-draw6', color: 'black', value: '+6' };
            ['mas 6.png', 'mas 6 dos .png', 'mas 6 3.png'].forEach(img => {
                // Antes: 2 copias. Ahora: 4 copias de cada una.
                for(let k=0; k<4; k++) deck.push({ ...d6, id: id++, image: img });
            });

            const d10 = { type: 'wild-draw10', color: 'black', value: '+10' };
            ['mas10.png', 'mas10 dos.png', 'mas10  tres.png'].forEach(img => {
                // Antes: 2 copias. Ahora: 4 copias de cada una.
                for(let k=0; k<4; k++) deck.push({ ...d10, id: id++, image: img });
            });

            const rev4 = { type: 'wild-reverse-draw4', color: 'black', value: 'R+4' };
            ['reversa mas4 uno.png', 'reversa mas4 dos.png', 'reversa mas4  tres.png', 'reversa mas4 - cuatro.png'].forEach(img => {
                // Antes: 2 copias. Ahora: 4 copias de cada una.
                for(let k=0; k<4; k++) deck.push({ ...rev4, id: id++, image: img });
            });

            const roulette = { type: 'wild-color-roulette', color: 'black', value: 'C' };
            ['sad face.png', 'sad face dos.png', 'sad face 3.png', 'sad face cuatro.png'].forEach(img => {
                deck.push({ ...roulette, id: id++, image: img }); deck.push({ ...roulette, id: id++, image: img });
            });

            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // L√ìGICA DE JUEGO
        startGameBtn.addEventListener('click', async () => {
            if (currentGameData.creatorUid !== currentUser.uid) return;
            const deck1 = createSingleDeck(); const deck2 = createSingleDeck();
            let fullDeck = shuffleDeck([...deck1, ...deck2]);
            fullDeck.forEach((c, i) => c.id = i);

            let data = { ...currentGameData, status: 'playing', gamePhase: 'playing', deck: fullDeck };
            data.players.forEach(p => { p.hand = data.deck.splice(0, 7); p.cardCount = 7; p.isSafe = false; p.status = 'playing'; });
            
            let firstIndex = data.deck.findIndex(c => c.type === 'number');
            if (firstIndex === -1) firstIndex = 0;
            data.discardPile = [data.deck.splice(firstIndex, 1)[0]];
            
            data.lastColorCalled = null; data.drawStack = 0; data.playDirection = 1; data.currentPlayerIndex = 0;
            data.message = `Turno de ${data.players[0].name}.`;
            await setDoc(gameRef, data);
        });

        async function onCardClick(card) {
            if (!isMyTurn() || !amIActive()) return;
            
            if (currentGameData.gamePhase === 'roulette-draw') {
                messageEl.textContent = "¬°Est√°s en castigo Sad Face! Debes robar hasta encontrar el color.";
                return; 
            }

            if (!isCardPlayable(card)) { messageEl.textContent = "Carta inv√°lida."; return; }
            
            if (card.color === 'black') {
                pendingWildCard = card;
                colorPickerModal.classList.remove('hidden');
            } else {
                await playCard(card, card.color);
            }
        }

        deckPile.addEventListener('click', async () => {
            if (!isMyTurn() || !amIActive()) return;
            let data = { ...currentGameData };
            let player = data.players[data.currentPlayerIndex];

            // 1. Sad Face / Ruleta
            if (data.gamePhase === 'roulette-draw') {
                const colorToFind = data.lastColorCalled;
                if (data.deck.length === 0) refillDeck(data);
                
                if (data.deck.length === 0) { 
                    data.gamePhase = 'playing';
                    data.message = "¬°Mazo vac√≠o! Fin del castigo.";
                    advanceTurn(data);
                    await updateDoc(gameRef, data); return;
                }

                let drawn = data.deck.pop();
                player.hand.push(drawn); player.cardCount++; player.isSafe = false;

                if (player.cardCount > 25) {
                    player.status = 'lost';
                    data.message = `¬°${player.name} PERDI√ì (>25 cartas)!`;
                    data.gamePhase = 'playing';
                    if (!checkEndGame(data)) advanceTurn(data);
                } else if (drawn.color === colorToFind) {
                    data.gamePhase = 'playing';
                    data.message = `${player.name} encontr√≥ ${colorToFind}.`;
                    advanceTurn(data);
                } else {
                    data.message = `${player.name} busca ${colorToFind}...`;
                }
                await updateDoc(gameRef, data); return;
            }

            // 2. Robo Normal o Robo por Repite
            let newCards = [];
            if (data.gamePhase === 'repeat-play') {
                 if (data.deck.length === 0) refillDeck(data);
                 if (data.deck.length > 0) {
                     let c = data.deck.pop();
                     player.hand.push(c); player.cardCount++;
                     if (c.color === data.mustPlayColor || c.type === 'repeat') {
                         data.message = `Rob√≥ 1. Puede jugarla si es ${data.mustPlayColor}.`;
                     } else {
                         data.gamePhase = 'playing'; 
                         data.mustPlayColor = null;
                         data.message = `Rob√≥ carta equivocada. Pasa turno.`;
                         advanceTurn(data);
                     }
                 }
            } else if (data.drawStack > 0) {
                // Robo acumulado
                let amount = Math.min(data.drawStack, data.deck.length);
                if (amount < data.drawStack) { refillDeck(data); amount += Math.min(data.drawStack - amount, data.deck.length); }
                
                newCards = data.deck.splice(0, amount);
                player.hand.push(...newCards); player.cardCount += newCards.length;
                data.drawStack = 0; data.stackType = null;
                data.message = `${player.name} comi√≥ ${newCards.length} cartas.`;
                advanceTurn(data);
            } else {
                // Robo simple
                if (data.deck.length === 0) refillDeck(data);
                if (data.deck.length > 0) {
                    newCards = data.deck.splice(0, 1);
                    player.hand.push(...newCards); player.cardCount++;
                    data.message = `${player.name} rob√≥ 1 carta.`;
                }
            }

            if (player.cardCount > 25) {
                player.status = 'lost';
                data.message = `¬°${player.name} PERDI√ì!`;
                if (!checkEndGame(data) && data.gamePhase !== 'repeat-play') advanceTurn(data);
            }

            await updateDoc(gameRef, data);
        });

        sayUnoBtn.addEventListener('click', async () => {
             if (currentGameData?.status !== 'playing') return;
             let data = { ...currentGameData };
             let me = data.players.find(p => p.uid === currentUser.uid);
             if (me && me.cardCount === 1) { me.isSafe = true; await updateDoc(gameRef, { players: data.players }); }
        });

        colorPickerModal.addEventListener('click', async (e) => {
            if (e.target.classList.contains('color-choice-btn')) {
                const color = e.target.dataset.color;
                const c = pendingWildCard; pendingWildCard = null;
                colorPickerModal.classList.add('hidden');
                await playCard(c, color);
            }
        });

        // HELPERS
        function isMyTurn() { return currentGameData?.players[currentGameData.currentPlayerIndex]?.uid === currentUser.uid; }
        function amIActive() { return currentGameData?.players.find(p => p.uid === currentUser.uid)?.status === 'playing'; }
        
        function refillDeck(data) {
            if (data.discardPile.length > 1) {
                const top = data.discardPile.pop();
                data.deck = shuffleDeck(data.discardPile);
                data.discardPile = [top];
            }
        }

        function isCardPlayable(card) {
            const data = currentGameData;
            const top = data.discardPile[data.discardPile.length - 1];

            if (data.gamePhase === 'repeat-play') {
                return card.color === data.mustPlayColor || (card.type === 'repeat' && card.color === data.mustPlayColor);
            }

            if (data.drawStack > 0) {
                if (data.stackType === 'draw2/4') return card.type === 'draw2' || card.type === 'draw4';
                if (data.stackType === 'draw6/10') return card.type === 'wild-draw6' || card.type === 'wild-draw10';
                if (data.stackType === 'draw4Reverse') return card.type === 'wild-reverse-draw4';
                return false;
            }

            if (card.color === 'black') return true;
            if (data.lastColorCalled) return card.color === data.lastColorCalled;
            
            const isTopDraw = ['draw2', 'draw4'].includes(top.type);
            const isCardDraw = ['draw2', 'draw4'].includes(card.type);
            if (isTopDraw && isCardDraw) return true;

            return card.color === top.color || card.value === top.value;
        }

        async function playCard(card, chosenColor) {
            let data = { ...currentGameData };
            let player = data.players[data.currentPlayerIndex];
            
            const idx = player.hand.findIndex(c => c.id === card.id);
            if (idx === -1) return;
            player.hand.splice(idx, 1);
            player.cardCount = player.hand.length;
            data.discardPile.push(card);

            data.lastColorCalled = null;
            let turnAdvances = true;
            let specialEventMsg = ""; // Para guardar mensajes especiales que no se borren

            if (data.gamePhase === 'repeat-play') {
                data.gamePhase = 'playing';
                data.mustPlayColor = null;
            }

            switch (card.type) {
                case 'number':
                    if (card.value === '0') {
                        const activePlayers = data.players.filter(p => p.status === 'playing');
                        const activeHands = activePlayers.map(p => p.hand);
                        const lastH = activeHands.pop(); 
                        activeHands.unshift(lastH);
                        activePlayers.forEach((p, i) => { 
                            p.hand = activeHands[i]; 
                            p.cardCount = p.hand.length; 
                            p.isSafe = false; 
                        });
                        specialEventMsg = "¬°CARTA 0! Rotaci√≥n de manos.";
                    }
                    if (card.value === '7') {
                        data.gamePhase = 'swap-hand-choice';
                        data.message = `${player.name} elige intercambio.`;
                        turnAdvances = false;
                    }
                    break;
                case 'reverse':
                    data.playDirection *= -1;
                    specialEventMsg = "¬°Reversa!";
                    break;
                case 'skip':
                    data.currentPlayerIndex = getNextPlayerIndex(data);
                    specialEventMsg = "¬°Bloqueo!";
                    break;
                case 'repeat':
                    data.gamePhase = 'repeat-play';
                    data.mustPlayColor = card.color;
                    data.message = `¬°REPITE! ${player.name} juega otra ${card.color}.`;
                    turnAdvances = false;
                    break;

                // CORRECCI√ìN: MENSAJE VISIBLE DE "BAJAR TODO"
                case 'discard-all':
                    const cColor = card.color;
                    let count = 0;
                    for (let i = player.hand.length - 1; i >= 0; i--) {
                        if (player.hand[i].color === cColor) {
                            data.discardPile.push(player.hand.splice(i, 1)[0]);
                            count++;
                        }
                    }
                    player.cardCount = player.hand.length;
                    specialEventMsg = `¬°${player.name} BAJ√ì TODO ${cColor.toUpperCase()}!`;
                    break;

                case 'draw2': data.stackType = 'draw2/4'; data.drawStack += 2; break;
                case 'draw4': data.stackType = 'draw2/4'; data.drawStack += 4; break;
                case 'wild-draw6': data.stackType = 'draw6/10'; data.drawStack += 6; data.lastColorCalled = chosenColor; break;
                case 'wild-draw10': data.stackType = 'draw6/10'; data.drawStack += 10; data.lastColorCalled = chosenColor; break;
                case 'wild-reverse-draw4': 
                    data.stackType = 'draw4Reverse'; data.drawStack += 4; 
                    data.playDirection *= -1; data.lastColorCalled = chosenColor; 
                    break;
                case 'wild-color-roulette':
                    data.gamePhase = 'roulette-draw';
                    data.lastColorCalled = chosenColor;
                    const nextPlayerIndex = getNextPlayerIndex(data);
                    const vName = data.players[nextPlayerIndex].name;
                    data.message = `¬°Sad Face! ${vName} debe buscar ${chosenColor}.`;
                    data.currentPlayerIndex = nextPlayerIndex; 
                    turnAdvances = false; 
                    break;
            }

            const cardName = card.type === 'number' ? card.value : (card.type === 'wild-color-roulette' ? 'Sad Face' : (card.type === 'discard-all' ? 'Bajar Color' : card.type));
            const colorText = card.color !== 'black' ? card.color : chosenColor;
            const chatMsgText = `${player.name} jug√≥ ${cardName}${colorText ? ` (${colorText})` : ''}.`;
            await updateDoc(gameRef, { chatMessages: arrayUnion({ senderName: 'Sistema', senderUid: 'system', text: chatMsgText, timestamp: new Date() }) });

            if (player.cardCount === 0) {
                data.status = 'finished';
                data.message = `¬°${player.name} GAN√ì!`;
            } else {
                if (player.cardCount > 1) player.isSafe = false;
                if (turnAdvances) {
                    advanceTurn(data);
                    // AQU√ç EST√Å EL TRUCO: Concatenar el mensaje especial para que no se pierda
                    if (specialEventMsg) {
                        data.message = `${specialEventMsg} ‚Üí ${data.message}`;
                    }
                }
            }
            await updateDoc(gameRef, data);
        }

        function getNextPlayerIndex(data, ignoreLost = true) {
            let idx = data.currentPlayerIndex;
            const len = data.players.length;
            let attempts = 0;
            const activeCount = data.players.filter(p => p.status === 'playing').length;
            if (activeCount <= 1 && ignoreLost) return idx;

            do {
                idx = (idx + data.playDirection + len) % len;
                attempts++;
            } while (data.players[idx].status === 'lost' && attempts < len * 2);
            return idx;
        }

        function advanceTurn(data) {
            data.currentPlayerIndex = getNextPlayerIndex(data);
            const nextP = data.players[data.currentPlayerIndex];
            if (data.gamePhase === 'playing') data.message = `Turno de ${nextP.name}.`;
        }

        function checkEndGame(data) {
            const active = data.players.filter(p => p.status === 'playing');
            if (active.length <= 1) {
                data.status = 'finished';
                data.message = active.length === 1 ? `¬°${active[0].name} GAN√ì (√önico sobreviviente)!` : "¬°Todos perdieron!";
                return true;
            }
            return false;
        }

        window.performHandSwap = async (targetUid) => {
            let data = { ...currentGameData };
            const curr = data.players[data.currentPlayerIndex];
            const target = data.players.find(p => p.uid === targetUid);
            if (!curr || !target) return;

            swapHandModal.classList.add('hidden');

            const tempH = curr.hand; const tempC = curr.cardCount;
            curr.hand = target.hand; curr.cardCount = target.cardCount; curr.isSafe = false;
            target.hand = tempH; target.cardCount = tempC; target.isSafe = false;

            data.gamePhase = 'playing';
            data.message = `¬°${curr.name} intercambi√≥ manos con ${target.name}!`;

            const chatMsgText = `${curr.name} activ√≥ la Carta 7 e intercambi√≥ manos con ${target.name}.`;
            await updateDoc(gameRef, { chatMessages: arrayUnion({ senderName: 'Sistema', senderUid: 'system', text: chatMsgText, timestamp: new Date() }) });

            advanceTurn(data);
            await updateDoc(gameRef, data);
        }
    </script>
</body>
</html>
